Aufgabe 1)
http.request.method == POST (Im Paket 213 mit der Info "POST /login.php HTTP/1.1 (application/x-www-form-urlencoded)" befindet sich das Passwort "dzh20szq")
http.response.code > 200 (Unter den 6 Übrigen ist ein Paket mit response code 401 mit der sehr auffälligen Flag "ra6rgv7h")
icmp (2 ping-pakete, in beiden befindet sich "nd7hark3" als Payload)

Aufgabe 2)
Benutzt man Traceroute um einen Server zu erreichen, bekommt man auf jedem "Zwischenschritt" den das Paket nimmt eine Nachricht von jedem weiterleitenden Router zurück, die dessen Adresse enthält. Gleichzeitig wird die Latenz zu diesem Router gemessen und alles wird in jeweils einer Zeile im Terminal angezeigt. Wenn das Paket den gesuchten Server erreicht, schickt dieser ebenfalls ein solches Paket zurück und das Programm terminiert erfolgreich. Im falle von „tracert 8.8.8.8“ funktioniert dies einwandfrei, bei "tracert www.anu.edu.au" sieht man allerdings ein "Problem". Da es sich bei diesem Zielserver um die National University von Australien handelt und diese praktischerweise am anderen Ende der Welt liegt, muss das Paket einen sehr weiten Weg zurück legen. Natürlich ist dementsprechend auch die Latenz sehr groß. so groß, dass ab einem gewissen Punkt kein Paket mehr den Weg zu uns zurück findet. Woran liegt das? Jedes Paket das Tracert ins Netz schickt hat einen "Timer" und wenn dieser ab läuft, wird das Paket bei seiner nächsten Station gelöscht. Das passiert auch mit den meisten Paketen, die spätere Stationen uns zurück schicken, wir bekommen Ausgaben wie " 10     *        *        *     Zeitüberschreitung der Anforderung." zurück und irgendwann terminiert Traceroute mit der Aussage, dass das Zielnetz nicht erreichbar ist.

Aufgabe 3)
In meinen Tests war der TCP Scan mit -sS in 5 Sekunden abgeschlossen, während der UDP Scan mit -sU knapp über 15 Minuten gebraucht hat um alle Ports zu scannen. Dies liegt an der funktionsweise der beiden Protokolle und Scans.
Da TCP vor der Datenübertragung eine Virtuelle Verbindung zwischen zwei Geräten aufbaut reicht es genau diesen Verbindungskanal aufzubauen um den Port zu scannen. Der Scan mit -sS öffnet keine volle TCP Verbindung sondern beschränkt sich auf eben diesen Verbindungskanal. Dies ist mit UDP nicht möglich, da UDP keine Verbindung von Gerät zu Gerät aufbaut. Dadurch garantiert UDP zwar eine niedrigere Latenz und es braucht weniger Bandbreite, um Ports zu scannen müssen allerdings trotzdem komplette Datenpakete versendet und empfangen werden, wodurch ein Scan mit -sU deutlich länger dauert als mit -sS. Um diesen Scan zu beschleunigen erlaubt Nmap gleichzeitiges Scannen nach beiden Protokollen, sodass garantiert geschlossene Ports direkt mit dem TCP Scan für den UDP Scan aussortiert werden.

Aufgabe 4)
Da das Programmieren dieser Funktionalität eine komplette Katastrophe war, teile ich meine Idee auf diesem Weg.
Die Überlegung beläuft sich darauf, dass jedes Mitglied des Rings ein Paket zurück an das jeweils zurück liegende Mitglied sendet, sobald es ein Token empfängt. Dadurch weis das jeweils vorherige Mitglied, dass das Token auch angekommen ist. Bekommt dieses Mitglied kein Bestätigungspaket zurück, wird das Token an das jeweils nächste Mitglied geschickt. Dafür müsste allerdings jedes Mitglied in seiner Antwort eine Referenz auf das nachfolgende Mitglied an das vorhergegangene Mitglied schicken. Dadurch lässt sich gewährleisten, dass einzelne Mitglieder ausfallen können und der Ring nicht zusammenfällt. 
